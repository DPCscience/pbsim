#' Create a crossing block from a vector of parents
#' 
#' @description 
#' Create a crossing block based on parent names, with different options for
#' mating scheme.
#' 
#' @param parents A \code{character} of line names to use as parents. If
#' \code{second.parents} is not provided, crosses are assigned from randomly sampling
#' the entries in \code{parents}.
#' @param second.parents A \code{character} of line names to use as parents. If
#' not \code{NULL}, must be the same length as \code{parents}. Crosses are formed
#' by randomly pairing the entries in \code{parents} with those in 
#' \code{second.parents}, unless \code{scheme = "pass"} is specified.
#' @param n.crosses The number of crosses to generate. Cannot be more than the
#' possible number of crosses.
#' @param scheme The mating scheme. Can be one of \code{"random"} or \code{chain}.
#' See \emph{Details} for more information.
#' @param use.parents.once \code{Logical} - should parents be used only once?
#' 
#' @details  
#' Several options are available to generate crossing blocks from a list of
#' parents. Here are the rules used for generating different crossing blocks.
#' 
#' \describe{
#'   \item{\code{scheme = "random"}}{A \code{data.frame} is first constructed with
#'   all possible pairwise combinations of \code{parents} and \code{second.parents}
#'   (see below for handling of \code{second.parents}). Self-crosses and reciprocal
#'   crosses are removed and \code{n.crosses} crosses are randomly sampled. If
#'   \code{use.parents.once = TRUE}, crosses are selected such that any one parent
#'   is used only once.}
#'   \item{\code{scheme = "chain"}}{Crosses are generated by pairing the first element
#'   in \code{parents} with the second element, the second element with the third,
#'   and so on. The \code{n.crosses} and \code{use.parents.once} arguments are ignored.}
#' }
#' 
#' Further rules:
#' 
#' \itemize{
#'   \item{If \code{second.parents = NULL}, then \code{parents} is duplicated.}
#' }
#' 
#' @return 
#' A data.frame with two columns. The first is the names of the first parents, 
#' and the second is the name of the second parents. Each row is a mating pair.
#' 
#' @examples 
#' 
#' parents <- paste("line", seq(10), sep = "")
#' 
#' # Generate 3 crosses randomly
#' cb <- sim_crossing_block(parents = parents, n.crosses = 3)
#' 
#' # Generate 3 crosses randomly, while only using parents once
#' cb <- sim_crossing_block(parents = parents, n.crosses = 3, use.parents.once = T)
#' 
#' # Generate a chain of crosses
#' cb <- sim_crossing_block(parents = parents, scheme = "chain")
#' 
#' ## Use another vector of parents
#' second.parents <- paste("line", seq(11, 20), sep = "")
#' 
#' cb <- sim_crossing_block(parents = parents, second.parents = second.parents, n.crosses = 3)
#' 
#' # When using scheme = "chain", second.parents is ignored
#' cb <- sim_crossing_block(parents = parents, second.parents = second.parents, scheme = "chain")
#' 
#' @import dplyr
#' 
#' @export
#' 
sim_crossing_block <- function(parents, second.parents, n.crosses, scheme = c("random", "chain"), 
                               use.parents.once = FALSE) {
  
  # Error
  if (!is.character(parents)) 
    stop("The input 'parents' must be a character.")
  
  if (!missing(second.parents)) {
    if (!is.character(second.parents))
      stop("The input 'second.parents' must be a character.")
  
  } else {
    # Else copy the parent vector
    second.parents <- parents
  }
  
  # Is method a correct choice?
  scheme <- match.arg(scheme)
  
  # Run depending on scheme 
  if (scheme == "random") {
    
    # How many unique parents
    n_unique <- n_distinct(c(parents, second.parents))
    
    # Generate all pairwise crosses minus selfs and reciprocals
    sample_crosses <- expand.grid(parent2 = second.parents, parent1 = parents, stringsAsFactors = FALSE) %>%
      select(parent1, parent2) %>%
      filter(parent1 != parent2)
    
    # Find reciprocals
    reciprocals <- apply(X = sample_crosses, MARGIN = 1, FUN = sort) %>% 
      t() %>% 
      duplicated()
    
    sample_crosses1 <- sample_crosses %>% 
      filter(!reciprocals)
    
    # Sample n.crosses from the sample crosses
    chosen_crosses <- sample_crosses1 %>%
      sample_n(n.crosses) %>%
      data.frame(row.names = NULL)
    
    # Use parents once?
    if (use.parents.once) {
      
      # Make sure the number of crosses is not more than half the number of 
      # unique parents
      if (n.crosses > (n_unique / 2)) 
        stop("The number of requested crosses exceeds those possible with 'use.parents.once' = TRUE.")
      
      # Count the occurence of all parents
      par_count <- table(unlist(chosen_crosses))
      
      # While any number is greater than 1, resample
      while (any(par_count > 1)) {
        
        chosen_crosses <- sample_crosses1 %>%
          sample_n(n.crosses) %>%
          data.frame(row.names = NULL)
        
        # Count the occurence of all parents
        par_count <- table(unlist(chosen_crosses))
        
      }
      
    }
    
    
  } else if (scheme == "chain") {
    # Chain scheme
    
    # The number of crosses is equal to the number of parents
    n.crosses <- length(parents)
    
    # Create an empty data.frame
    chosen_crosses <- as.data.frame(
      matrix(NA, nrow = n.crosses, ncol = 2, dimnames = list(NULL, c("parent1", "parent2")))
    )
    
    # Add parents to the df
    chosen_crosses$parent1 <- parents
    chosen_crosses$parent2 <- c(tail(parents, -1), head(parents, 1))
    
  }
  
  # Return the crossing_block
  return(chosen_crosses)


} # Close the function