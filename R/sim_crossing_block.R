#' Create a crossing block from a vector of parents
#' 
#' @description 
#' Create a crossing block based on parent names, with different options for
#' mating scheme.
#' 
#' @param parents A \code{character} of line names to use as parents. If
#' \code{second.parents} is not provided, crosses are assigned from randomly sampling
#' the entries in \code{parents}.
#' @param second.parents A \code{character} of line names to use as parents. If
#' passed, must be the same length as \code{parents}.
#' @param n.crosses The number of crosses to generate. Cannot be more than the
#' possible number of crosses.
#' @param scheme The mating scheme. Can be one of \code{"random"} or \code{"chain"}.
#' See \emph{Details} for more information.
#' @param use.parents.once \code{Logical} - should parents be used only once?
#' 
#' @details  
#' Several options are available to generate crossing blocks from a list of
#' parents. Here are the rules used for generating different crossing blocks.
#' 
#' \describe{
#'   \item{\code{scheme = "random"}}{A \code{data.frame} is first constructed with
#'   all possible pairwise combinations of \code{parents} and \code{second.parents}
#'   (see below for handling of \code{second.parents}). Self-crosses and reciprocal
#'   crosses are removed and \code{n.crosses} crosses are randomly sampled. If
#'   \code{use.parents.once = TRUE}, crosses are selected such that any one parent
#'   is used only once.}
#'   \item{\code{scheme = "chain"}}{Crosses are generated by pairing the first element
#'   in \code{parents} with the second element, the second element with the third,
#'   and so on. The \code{n.crosses} and \code{use.parents.once} arguments are ignored.}
#' }
#' 
#' Further rules:
#' 
#' \itemize{
#'   \item{If \code{second.parents = NULL}, then \code{parents} is duplicated.}
#' }
#' 
#' @return 
#' A data.frame with two columns. The first is the names of the first parents, 
#' and the second is the name of the second parents. Each row is a mating pair.
#' 
#' @examples 
#' 
#' parents <- paste("line", seq(10), sep = "")
#' 
#' # Generate 3 crosses randomly
#' cb <- sim_crossing_block(parents = parents, n.crosses = 3)
#' 
#' # Generate 3 crosses randomly, while only using parents once
#' cb <- sim_crossing_block(parents = parents, n.crosses = 3, use.parents.once = T)
#' 
#' # Generate a chain of crosses
#' cb <- sim_crossing_block(parents = parents, scheme = "chain")
#' 
#' ## Use another vector of parents
#' second.parents <- paste("line", seq(11, 20), sep = "")
#' 
#' cb <- sim_crossing_block(parents = parents, second.parents = second.parents, n.crosses = 3)
#' 
#' # When using scheme = "chain", second.parents is ignored
#' cb <- sim_crossing_block(parents = parents, second.parents = second.parents, scheme = "chain")
#' 
#' @import dplyr
#' 
#' @export
#' 
sim_crossing_block <- function(parents, second.parents, n.crosses, scheme = c("random", "chain"), 
                               use.parents.once = FALSE) {
  
  # Error
  if (!is.character(parents)) 
    stop("The input 'parents' must be a character.")
  
  if (!missing(second.parents)) {
    if (!is.character(second.parents))
      stop("The input 'second.parents' must be a character.")
  
  } else {
    # Else copy the parent vector
    second.parents <- parents
  }
  
  # Is method a correct choice?
  scheme <- match.arg(scheme)
  
  # Run depending on scheme 
  if (scheme == "random") {
    
    # How many unique parents
    n_unique <- n_distinct(c(parents, second.parents))
    
    # Generate all pairwise crosses minus selfs and reciprocals
    sample_crosses <- expand.grid(parent2 = second.parents, parent1 = parents, stringsAsFactors = FALSE) %>%
      select(parent1, parent2) %>%
      filter(parent1 != parent2)
    
    # Find reciprocals and remove
    sample_crosses1 <- sample_crosses %>% 
      mutate(key = paste(pmin(parent1, parent2), pmax(parent1, parent2), sep = "")) %>% 
      distinct(key, .keep_all = TRUE) %>%
      select(-key)
    
    # Sample n.crosses from the sample crosses
    chosen_crosses <- sample_crosses1 %>%
      sample_n(n.crosses) %>%
      data.frame(row.names = NULL)
    
    # Use parents once?
    if (use.parents.once) {
      
      # Make sure the number of crosses is not more than half the number of 
      # unique parents
      if (n.crosses > (n_unique / 2)) 
        stop("The number of requested crosses exceeds those possible with 'use.parents.once' = TRUE.")
      
      # Count the occurence of all parents
      par_count <- table(unlist(chosen_crosses))
      
      # While any number is greater than 1, resample
      while (any(par_count > 1)) {
        
        chosen_crosses <- sample_crosses1 %>%
          sample_n(n.crosses) %>%
          data.frame(row.names = NULL)
        
        # Count the occurence of all parents
        par_count <- table(unlist(chosen_crosses))
        
      }
      
    }
    
    
  } else if (scheme == "chain") {
    # Chain scheme
    
    # The number of crosses is equal to the number of parents
    n.crosses <- length(parents)
    
    # Create an empty data.frame
    chosen_crosses <- as.data.frame(
      matrix(NA, nrow = n.crosses, ncol = 2, dimnames = list(NULL, c("parent1", "parent2")))
    )
    
    # Add parents to the df
    chosen_crosses$parent1 <- parents
    chosen_crosses$parent2 <- c(tail(parents, -1), head(parents, 1))
    
  }
  
  # Return the crossing_block
  return(chosen_crosses)


} # Close the function



#' Calculate the expected genetic variance in simulated families
#' 
#' 
#' @description 
#' Calculates the expected genetic variance of a cross, assuming complete selfing.
#' 
#' @param genome An object of class \code{genome}.
#' @param pedigree A \code{pedigree} detailing the scheme to develop the family.
#' Use \code{\link{sim_pedigree}} to generate.
#' @param founder.pop An object of class \code{pop} with the geno information for
#' the parents. Additional individuals can be present in \code{parent_pop}. They
#' will be filtered according to the parents in the \code{crossing.block}.
#' @param crossing.block A crossing block detailing the crosses to make. Must be a
#' \code{data.frame} with 2 columns: the first gives the name of parent 1, and the 
#' second gives the name of parent 2. See \code{\link{sim_crossing.block}}.
#' 
#' @examples 
#' 
#' # Simulate a genome
#' n.mar  <- c(505, 505, 505)
#' len <- c(120, 130, 140)
#' 
#' genome <- sim_genome(len, n.mar)
#' 
#' # Simulate a quantitative trait influenced by 50 QTL
#' qtl.model <- matrix(NA, 50, 4)
#' genome <- sim_gen_model(genome = genome, qtl.model = qtl.model, 
#'                         add.dist = "geometric", max.qtl = 50)
#' 
#' # Simulate the genotypes for 8 founders
#' founder.pop <- sim_founders(genome = genome, n.str = 8)
#' 
#' # Generate a crossing block with 5 crosses
#' cb <- sim_crossing_block(parents = indnames(founder.pop), n.crosses = 5)
#' 
#' # Create a pedigree with 100 individuals selfed to the F_3 generation
#' ped <- sim_pedigree(n.ind = 100, n.selfgen = 2)
#' 
#' calc_exp_genvar(genome = genome, pedigree = ped, founder.pop = founder.pop, 
#'                 crossing.block = cb)
#'                 
#' 
#' ## If two traits are present, the genetic correlation is calculated
#' # Simulate two quantitative traits influenced by 50 pleiotropic QTL
#' qtl.model <- replicate(2, matrix(NA, 50, 4), simplify = FALSE)
#' genome <- sim_multi_gen_model(genome = genome, qtl.model = qtl.model, corr = 0.99, 
#'                               prob.corr = cbind(0, 1), add.dist = "normal")
#' 
#' # Simulate the genotypes for 8 founders
#' founder.pop <- sim_founders(genome = genome, n.str = 8)
#' 
#' calc_exp_genvar(genome = genome, pedigree = ped, founder.pop = founder.pop, 
#'                 crossing.block = cb)
#' 
#' 
#' 
#' @importFrom qtl mf.h
#' @importFrom simcross check_pedigree
#' @importFrom Matrix .bdiag
#' @importFrom tidyr crossing
#' 
#' @export
#' 
calc_exp_genvar <- function(genome, pedigree, founder.pop, crossing.block) {
  
  # Error handling
  if (!inherits(genome, "genome"))
    stop("The input 'genome' must be of class 'genome.'")
  
  # Check the pedigree
  if (!check_pedigree(pedigree, ignore_sex = TRUE))
    stop("The pedigree is not formatted correctly.")
  
  # Check the crossing block
  if (ncol(crossing.block) != 2) {
    stop("The crossing block should have two columns.")
  } else {
    crossing.block <- as.data.frame(crossing.block)
  }
  
  # founder.pop needs to be a pop object
  if (!inherits(founder.pop, "pop"))
    stop("The input 'founder.pop' must be of class 'pop'")
  
  # Check the genome and geno
  if (!check_geno(genome = genome, geno = founder.pop$geno))
    stop("The geno did not pass. See warning for reason.")
  
  ## How many traits
  n_traits <- length(genome$gen_model)
  
  # If it is more than 2, error out
  stopifnot(n_traits <= 2)
  
  
  ## Calculate the expected genetic variance
  
  
  ## What are the expected allele frequencies in the population?
  ## Is there any backcrossing?
  mom_ped <- pedigree[pedigree$mom == 1,]
  dad_ped <- pedigree[pedigree$mom == 2,]
  
  mom_dist_gen <- length(unique(mom_ped$gen))
  dad_dist_gen <- length(unique(dad_ped$gen))
  
  max_bc_gen <- pmax(mom_dist_gen, dad_dist_gen) - 1
  
  # The expected frequency of the minor allele is 0.5 ^ n_bc_gen + 1
  exp_q <- 0.5^(max_bc_gen + 1)
  exp_p <- 1 - exp_q
  
  # Get the QTL information
  qtl_info <- pull_qtl(genome, unique = FALSE)
  # Filter out QTL with no additive effect
  qtl_info <- qtl_info[qtl_info$add_eff != 0,,drop = FALSE]
  # Split by trait
  qtl_info_split <- split(qtl_info, qtl_info$trait)
  
  
  ## Iterate over traits
  qtl_covariance <- lapply(X = qtl_info_split, FUN = function(trait_qtl) {
  
    # Get the map and genotypes of only the QTL
    qtl_geno <- pull_genotype(genome = genome, geno = founder.pop$geno, loci = trait_qtl$qtl_name) - 1
    
    ## Calculate the expected genetic variance and covariance of QTL
    trait_qtl_split <- split(trait_qtl, trait_qtl$chr)
  
    
    ## Calculate the expected covariance between QTL
    qtl_covar <- lapply(X = trait_qtl_split, FUN = function(qtl_chr) {
      d <- as.matrix(dist(qtl_chr$pos))

      # Calculate pairwise D (see Zhong and Jannink, 2007)
      # First convert cM to recombination fraction
      c <- qtl:::mf.h(d)
      D <- ((1 - (2 * c)) / (1 + (2 * c)))
      # # The diagonals are 0
      # diag(D) <- 0
      
      # Calculate the pairwise product of all QTL effects
      qtl_crossprod <- tcrossprod(qtl_chr$add_eff)
      dimnames(qtl_crossprod) <- list(qtl_chr$qtl_name, qtl_chr$qtl_name)
      
      # The covariance is the QTL effect product multiplied by the expected D
      qtl_crossprod * D
  
    })
    
    # Combine into a block diagonal, since the covariance between QTL on different chromosomes
    # is expected to be 0
    Cov <- .bdiag(qtl_covar)
    dimnames(Cov) <- list(trait_qtl$qtl_name, trait_qtl$qtl_name)
    # Return
    return(Cov)
    
  })
  
  ## Calculate the genetic covariance between QTL for different traits
  # Split by chromosome
  qtl_chr_split <- split(qtl_info, qtl_info$chr)
  
  
  if (n_traits > 1) {
  
    ## Iterate over chromosomes
    qtl_trait_covariance <- lapply(X = qtl_chr_split, FUN = function(chr_qtl) {
      
      # Split by trait
      trait_split <- split(chr_qtl, chr_qtl$trait)
      
      ## QTL names for each trait
      qtl_names <- lapply(X = trait_split, FUN = "[[", "qtl_name")
      qtl_pos <- lapply(X = trait_split, FUN = "[[", "pos")
      qtl_eff <- lapply(X = trait_split, FUN = function(q) as.matrix(q$add_eff))
      
      ## Calculate the pairwise distance
      d <- abs(outer(X = qtl_pos[[1]], Y = qtl_pos[[2]], FUN = `-`))
      # Calculate pairwise D (see Zhong and Jannink, 2007)
      # First convert cM to recombination fraction
      c <- qtl:::mf.h(d)
      D <- ((1 - (2 * c)) / (1 + (2 * c)))
      
      # Product of QTL effects
      qtl_crossprod <- tcrossprod(qtl_eff[[1]], qtl_eff[[2]])
      dimnames(qtl_crossprod) <- qtl_names
      
      # The covariance is the QTL effect product multiplied by the expected D
      qtl_crossprod * D
      
    })
    
    # Combine into a block diagonal, since the covariance between QTL on different chromosomes
    # is expected to be 0
    traitCov <- .bdiag(qtl_trait_covariance)
    dimnames(traitCov) <- list(qtl_info_split[[1]]$qtl_name, qtl_info_split[[2]]$qtl_name)
    
  } else {
    traitCov <- NULL
    
  }
      

  ## Now we iterate over the parent pairs to determine the QTL that are segregating
  
  # Replicate the crossing block 
  
  ## Add columns to the crossing.block for exp mu and exp varG
  crossing_block <- crossing(crossing.block, trait = paste0("trait", seq(length(genome$gen_model))))
  exp_mu <- list()
  exp_varG <- list()
  exp_corG <- list()
  
  # Iterate over the crossing block
  for (j in seq(nrow(crossing.block))) {
    
    pars <- as.character(crossing.block[j,1:2])
    
    ## Pull out the qtl genotypes for each trait
    qtl_names <- lapply(X = qtl_info_split, FUN = "[[", "qtl_name")
    qtl_geno <- lapply(X = qtl_names, pull_genotype, genome = genome, geno = founder.pop$geno)
    
    ## Get a list of the polymorphic QTL
    poly_qtl_list <- lapply(X = qtl_geno, FUN = function(tr_qtl) {
      
      # Subset the parents
      par_qtl_geno <- tr_qtl[pars,,drop = FALSE] - 1
      qtl_means <- colMeans(par_qtl_geno)
      poly_qtl <- names(qtl_means)[qtl_means == 0]
      # Get the marker states for parent 1 - use this to determine phase
      par_qtl_geno[1, poly_qtl, drop = F]
      
    })
    
    # Iterate over the traits
    trait_var <- mapply(poly_qtl_list, qtl_covariance, FUN = function(poly_mat, qtl_cov) {
      
      poly_qtl <- colnames(poly_mat)
      exp_covar1 <- as.matrix(qtl_cov)[poly_qtl, poly_qtl] * crossprod(poly_mat)
      
      # The expected variance is the sum of the variances at the polymorphic QTL, plus 2 times
      # the expected covariance between all polymorphic QTL
      # One can simply sum up the elements in the covariance matrix
      sum(exp_covar1)
      
    })
    
    if (!is.null(traitCov)) {
      
      poly_qtl_names <- lapply(poly_qtl_list, colnames)
      ## Calculate the expected covariance
      trait_cov <- as.matrix(traitCov)[poly_qtl_names[[1]], poly_qtl_names[[2]]] * crossprod(poly_qtl_list[[1]], poly_qtl_list[[2]])
      # The covariance is 2 times the sum of this matrix (it is not diagonal)
      trait_cov1 <- sum(trait_cov)
      
      # The expected correlation is calculated using the expected sd and expected cov
      exp_corG_j <- trait_cov1 / prod(sqrt(trait_var)) 
      exp_corG[[j]] <- rep(exp_corG_j, 2)
      
    }
      
    # The expected mu is simply the mean of the genotypic values of the two parents
    exp_mu_j <- colMeans(founder.pop$geno_val[founder.pop$geno_val$ind %in% pars,-1,drop = F])
    
    ## Add to the lists
    exp_mu[[j]] <- exp_mu_j
    exp_varG[[j]] <- trait_var
    
  }
  
  ## Add the variances and means to the crossing block
  crossing_block$exp_mu <- unlist(exp_mu)
  crossing_block$exp_varG <- unlist(exp_varG)  
  crossing_block$exp_corG <- unlist(exp_corG)
  
  # Return the crossing block
  return(crossing_block)
  
}
