#' Create a crossing block from a vector of parents
#' 
#' @description 
#' Create a crossing block based on parent names, with different options for
#' mating scheme.
#' 
#' @param parents A \code{character} of line names to use as parents. If
#' \code{second.parents} is not provided, crosses are assigned from randomly sampling
#' the entries in \code{parents}.
#' @param second.parents A \code{character} of line names to use as parents. If
#' passed, must be the same length as \code{parents}.
#' @param n.crosses The number of crosses to generate. Cannot be more than the
#' possible number of crosses.
#' @param scheme The mating scheme. Can be one of \code{"random"} or \code{"chain"}.
#' See \emph{Details} for more information.
#' @param use.parents.once \code{Logical} - should parents be used only once?
#' 
#' @details  
#' Several options are available to generate crossing blocks from a list of
#' parents. Here are the rules used for generating different crossing blocks.
#' 
#' \describe{
#'   \item{\code{scheme = "random"}}{A \code{data.frame} is first constructed with
#'   all possible pairwise combinations of \code{parents} and \code{second.parents}
#'   (see below for handling of \code{second.parents}). Self-crosses and reciprocal
#'   crosses are removed and \code{n.crosses} crosses are randomly sampled. If
#'   \code{use.parents.once = TRUE}, crosses are selected such that any one parent
#'   is used only once.}
#'   \item{\code{scheme = "chain"}}{Crosses are generated by pairing the first element
#'   in \code{parents} with the second element, the second element with the third,
#'   and so on. The \code{n.crosses} and \code{use.parents.once} arguments are ignored.}
#' }
#' 
#' Further rules:
#' 
#' \itemize{
#'   \item{If \code{second.parents = NULL}, then \code{parents} is duplicated.}
#' }
#' 
#' @return 
#' A data.frame with two columns. The first is the names of the first parents, 
#' and the second is the name of the second parents. Each row is a mating pair.
#' 
#' @examples 
#' 
#' parents <- paste("line", seq(10), sep = "")
#' 
#' # Generate 3 crosses randomly
#' cb <- sim_crossing_block(parents = parents, n.crosses = 3)
#' 
#' # Generate 3 crosses randomly, while only using parents once
#' cb <- sim_crossing_block(parents = parents, n.crosses = 3, use.parents.once = T)
#' 
#' # Generate a chain of crosses
#' cb <- sim_crossing_block(parents = parents, scheme = "chain")
#' 
#' ## Use another vector of parents
#' second.parents <- paste("line", seq(11, 20), sep = "")
#' 
#' cb <- sim_crossing_block(parents = parents, second.parents = second.parents, n.crosses = 3)
#' 
#' # When using scheme = "chain", second.parents is ignored
#' cb <- sim_crossing_block(parents = parents, second.parents = second.parents, scheme = "chain")
#' 
#' @import dplyr
#' 
#' @export
#' 
sim_crossing_block <- function(parents, second.parents, n.crosses, scheme = c("random", "chain"), 
                               use.parents.once = FALSE) {
  
  # Error
  if (!is.character(parents)) 
    stop("The input 'parents' must be a character.")
  
  if (!missing(second.parents)) {
    if (!is.character(second.parents))
      stop("The input 'second.parents' must be a character.")
  
  } else {
    # Else copy the parent vector
    second.parents <- parents
  }
  
  # Is method a correct choice?
  scheme <- match.arg(scheme)
  
  # Run depending on scheme 
  if (scheme == "random") {
    
    # How many unique parents
    n_unique <- n_distinct(c(parents, second.parents))
    
    # Generate all pairwise crosses minus selfs and reciprocals
    sample_crosses <- expand.grid(parent2 = second.parents, parent1 = parents, stringsAsFactors = FALSE) %>%
      select(parent1, parent2) %>%
      filter(parent1 != parent2)
    
    # Find reciprocals and remove
    sample_crosses1 <- sample_crosses %>% 
      mutate(key = paste(pmin(parent1, parent2), pmax(parent1, parent2), sep = "")) %>% 
      distinct(key, .keep_all = TRUE) %>%
      select(-key)
    
    # Sample n.crosses from the sample crosses
    chosen_crosses <- sample_crosses1 %>%
      sample_n(n.crosses) %>%
      data.frame(row.names = NULL)
    
    # Use parents once?
    if (use.parents.once) {
      
      # Make sure the number of crosses is not more than half the number of 
      # unique parents
      if (n.crosses > (n_unique / 2)) 
        stop("The number of requested crosses exceeds those possible with 'use.parents.once' = TRUE.")
      
      # Count the occurence of all parents
      par_count <- table(unlist(chosen_crosses))
      
      # While any number is greater than 1, resample
      while (any(par_count > 1)) {
        
        chosen_crosses <- sample_crosses1 %>%
          sample_n(n.crosses) %>%
          data.frame(row.names = NULL)
        
        # Count the occurence of all parents
        par_count <- table(unlist(chosen_crosses))
        
      }
      
    }
    
    
  } else if (scheme == "chain") {
    # Chain scheme
    
    # The number of crosses is equal to the number of parents
    n.crosses <- length(parents)
    
    # Create an empty data.frame
    chosen_crosses <- as.data.frame(
      matrix(NA, nrow = n.crosses, ncol = 2, dimnames = list(NULL, c("parent1", "parent2")))
    )
    
    # Add parents to the df
    chosen_crosses$parent1 <- parents
    chosen_crosses$parent2 <- c(tail(parents, -1), head(parents, 1))
    
  }
  
  # Return the crossing_block
  return(chosen_crosses)


} # Close the function



#' Calculate the expected genetic variance in families from a crossing block
#' 
#' 
#' @description 
#' Calculates the expected genetic variance in a cross or crosses using a pedigree
#' and a crossing block.
#' 
#' @param genome An object of class \code{genome}.
#' @param pedigree A \code{pedigree} detailing the scheme to develop the family.
#' Use \code{\link{sim_pedigree}} to generate.
#' @param founder.pop An object of class \code{pop} with the geno information for
#' the parents. Additional individuals can be present in \code{parent_pop}. They
#' will be filtered according to the parents in the \code{crossing.block}.
#' @param crossing.block A crossing block detailing the crosses to make. Must be a
#' \code{data.frame} with 2 columns: the first gives the name of parent 1, and the 
#' second gives the name of parent 2. See \code{\link{sim_crossing.block}}.
#' 
#' 
#' @importFrom qtl mf.h
#' @importFrom simcross check_pedigree
#' @importFrom Matrix .bdiag
#' 
#' @export
#' 
calc_exp_genvar <- function(genome, pedigree, founder.pop, crossing.block) {
  
  # Error handling
  if (!inherits(genome, "genome"))
    stop("The input 'genome' must be of class 'genome.'")
  
  # Check the pedigree
  if (!check_pedigree(pedigree, ignore_sex = TRUE))
    stop("The pedigree is not formatted correctly.")
  
  # Check the crossing block
  if (ncol(crossing.block) != 2) {
    stop("The crossing block should have two columns.")
  } else {
    crossing.block <- as.data.frame(crossing.block)
  }
  
  # founder.pop needs to be a pop object
  if (!inherits(founder.pop, "pop"))
    stop("The input 'founder.pop' must be of class 'pop'")
  
  # Check the genome and geno
  if (!check_geno(genome = genome, geno = founder.pop$geno))
    stop("The geno did not pass. See warning for reason.")
  
  
  ## Calculate the expected genetic variance
  
  # First we need to know the expected inbreeding coefficient. This will be added to 1 to determine
  # the coefficient to multiply by the genetic variance
  expF <- if (attr(pedigree, "selfing") == "partial") {
    1 - (0.5^(max(pedigree$gen) - 2))
  } else {1}
  
  ## What are the expected allele frequencies in the population?
  ## Is there any backcrossing?
  mom_ped <- pedigree[pedigree$mom == 1,]
  dad_ped <- pedigree[pedigree$mom == 2,]
  
  mom_dist_gen <- length(unique(mom_ped$gen))
  dad_dist_gen <- length(unique(dad_ped$gen))
  
  max_bc_gen <- pmax(mom_dist_gen, dad_dist_gen) - 1
  
  # The expected frequency of the minor allele is 0.5 ^ n_bc_gen + 1
  exp_q <- 0.5^(max_bc_gen + 1)
  exp_p <- 1 - exp_q
  
  # Get the QTL information
  qtl_info <- pull_qtl(genome)
  qtl_info <- qtl_info[qtl_info$add_eff != 0,,drop = FALSE]

  # Get the map and genotypes of only the QTL
  qtl_geno <- pull_genotype(genome = genome, geno = founder.pop$geno, loci = qtl_info$qtl_name) - 1
  
  ## Calculate the expected genetic variance at each QTL, independent of other QTL
  ## Then sum
  qtl_info$exp_var <- 2 * exp_p * exp_q * qtl_info$add_eff^2
  # Split by chromosome
  qtl_info_split <- split(qtl_info, qtl_info$chr)

  
  ## Calculate the expected covariance between QTL
  qtl_covar <- lapply(X = qtl_info_split, FUN = function(qtl_chr) {
    d <- as.matrix(dist(qtl_chr$pos))
    dimnames(d) <- list(qtl_chr$qtl_name, qtl_chr$qtl_name)
    
    # Calculate pairwise D (see Zhong and Jannink, 2007)
    # First convert cM to recombination fraction
    c <- qtl:::mf.h(d)
    D <- ((1 - (2 * c)) / (1 + (2 * c)))
    # The diagonals are 0
    diag(D) <- 0
    
    # Calculate the pairwise product of all QTL effects
    qtl_crossprod <- crossprod(t(qtl_chr$add_eff))
    dimnames(qtl_crossprod) <- dimnames(d)
    
    # The covariance is the QTL effect product multiplied by the expected D
    qtl_crossprod * D

  })
  
  # Combine into a block diagonal, since the covariance between QTL on different chromosomes
  # is expected to be 0
  Cov <- .bdiag(qtl_covar)
  dimnames(Cov) <- list(qtl_info$qtl_name, qtl_info$qtl_name)
  
  ## Now we iterate over the parent pairs to determine the QTL that are segregating
  
  ## Add columns to the crossing.block for exp mu and exp varG
  crossing.block$exp_mu <- NA
  crossing.block$exp_var <- NA
  
  # Iterate over the crossing block
  for (j in seq(nrow(crossing.block))) {
    
    pars <- as.character(crossing.block[j,1:2])
    qtl_means <- colMeans(qtl_geno[pars,,drop = FALSE])
    poly_qtl <- names(qtl_means)[qtl_means == 0]
    
    # Get the expected variance from these QTL
    exp_var1 <- qtl_info$exp_var[qtl_info$qtl_name %in% poly_qtl]
    exp_covar1 <- as.matrix(Cov[poly_qtl, poly_qtl])
    
    # The expected variance is the sum of the variances at the polymorphic QTL, plus 2 times
    # the expected covariance between all polymorphic QTL
    exp_var_j <- sum(exp_var1) + (2 * sum(exp_covar1[upper.tri(exp_covar1)]))
    exp_var_j <- (1 + expF) * exp_var_j
    
    # The expected mu is simply the mean of the genotypic values of the two parents
    exp_mu_j <- colMeans(founder.pop$geno_val[founder.pop$geno_val$ind %in% pars,-1,drop = F])
  
    ## Add to crossing.block
    crossing.block$exp_mu[j] <- exp_mu_j
    crossing.block$exp_var[j] <- exp_var_j
    
  }
  
  # Return the crossing block
  return(crossing.block)
  
}
  
  
  
  
