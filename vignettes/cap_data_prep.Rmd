---
title: "Gather Genotype Data from T3"
author: "Jeff Neyhart"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This markdown file outlines the preparation of BOPA SNP genotype data two barley populations:

- Spring two-row from 5 U.S. breeding programs (n = 183)
- Spring six-row from 2 U.S. breeding programs (n = 768)

```{r libraries}

# Load packages
library(tidyverse)
library(stringr)
library(qtl)
library(pbsim)

# Define a function to take a matrix and compare all columns and return an index of the identical columns
identical.columns <- function(input.matrix) {
  
  # Error handling
  input.matrix <- as.matrix(input.matrix)
  
  # Save the vector 1:ncol(input.matrix)
  col.ind <- 1:ncol(input.matrix)
  
  # Create a comparison list
  comparison.list <- list()
  
  # Loop over the number of columns
  for (i in col.ind) {
    
    # Extract column i
    col.i <- input.matrix[,i]
    # Compare it to all other columns
    compare.i <- apply(X = as.matrix(input.matrix[,setdiff(col.ind, i)]), MARGIN = 2, FUN = function(column) identical(col.i, column) )
    # Find the columns that match
    col.compare <- setdiff(col.ind, i)[compare.i]
    
    # Add to the list
    comparison.list[[i]] <- sort(c(i, col.compare))
  }
  
  # Find the unique groups
  comparison.list <- unique(comparison.list)
  
  # Return the comparison list
  return(comparison.list)
} # Close the function

```

## Data Acquisition

The data were acquired from T3 and downloaded without any filters.

Two maps were downloaded for all SNPs

- 2009 consensus map from @Close2009
- 2011 consensus map from @Munoz-Amatriain2011

## Processing

### Two Row Barley Data


```{r process}



# Read in the data ### EDIT THIS ###
s2_genos <- read_tsv(file = "C:/Users/Jeff/Google Drive/Barley Lab/Projects/Genomic Selection/Genotypic Data/BOPA Markers/S2TP_BOPA/Unfiltered/genotype.hmp.txt")

# Extract the metadata (map, chromosome, etc)
snp_info <- s2_genos %>%
  select(rs:pos)

# Calculate cM position from the hecto-Morgan positions given
snp_info1 <- snp_info %>%
  mutate(cM_pos = pos / 1000) %>%
  select(-pos)


# Trim the genotype matrix
s2_genos_mat <- s2_genos %>%
  select(-rs:-pos) %>%
  mutate_each(funs = funs(parse_number)) %>%
  as.matrix()

# Add rownames
row.names(s2_genos_mat) <- snp_info1$rs

# Transpose
s2_genos_mat1 <- t(s2_genos_mat)

# Remove markers with > 10% missing data
marker_missing <- s2_genos_mat1 %>%
  is.na() %>%
  colMeans()

s2_genos_mat2 <- s2_genos_mat1[,marker_missing <= 0.10]

# Remove entries with > 10% missing data
entry_missing <- s2_genos_mat2 %>%
  is.na() %>%
  rowMeans()

s2_genos_mat3 <- s2_genos_mat2[entry_missing <= 0.10,]

# Remove markers with < 0.05 MAF
marker_MAF <- (s2_genos_mat3 + 1) %>%
  colMeans(na.rm = T) %>%
  {. / 2} %>% 
  sapply(FUN = function(freq) min(freq, 1-freq))

s2_genos_mat4 <- s2_genos_mat3[,marker_MAF >= 0.05]

# Trim the snp_info data.frame and remove unknown
snp_info2 <- snp_info1 %>% 
  filter(rs %in% colnames(s2_genos_mat4),
         chrom != "UNK")

# Remove the unknowns from the genotype matrix
s2_genos_mat5 <- s2_genos_mat4[,snp_info2$rs]


### Processing of the marker matrix for use in simulation
# Remove redundant markers
# These are characterized by having the same genotypes across all samples AND fall on the same cM position

# Split the marker information by unique position
unique_snp_list <- snp_info2 %>% 
  split(list(.$chrom, .$cM_pos))

# Remove NULL
unique_snp_list <- unique_snp_list[sapply(unique_snp_list, nrow) != 0]

# Apply a function to each group of unique SNPs
non.redundant.marker.list <- lapply(unique_snp_list, FUN = function(uniq_info) {
  
  # If the number of markers is 1, just return the marker
  if (nrow(uniq_info) == 1) {
    return(uniq_info)
    
  } else { # Otherwise look more closely
    
    # Extract the marker names
    marker.names <- uniq_info$rs

    M.i <- s2_genos_mat5[,marker.names, drop = FALSE]
    
    # Determine if the genotype calls are the same between markers
    same.genos <- identical.columns(input.matrix = M.i)
    
    # Choose the first index from each group
    # Gather the names of the chosen markers
    non.redundant.marker.names <- colnames(M.i)[sapply(X = same.genos, FUN = function(group) group[1])]
    
    # Extract marker info for those markers and return
    snp_info2 %>%
      filter(rs %in% non.redundant.marker.names)

  } })
    
# Collapse the list
snp_info3 <- bind_rows(non.redundant.marker.list) %>%
  arrange(chrom, cM_pos)

# Extract the map
gen_map <- snp_info3 %>% 
  split(.$chrom) %>% 
  map(select, cM_pos) %>% 
  map(unlist)

class(gen_map) <- "map"

# Jitter the map
gen_map_jitter <- jittermap(gen_map) %>%
  unlist()

# Replace the snp_info map
snp_info4 <- snp_info3 %>% 
  mutate(cM_pos = gen_map_jitter)

# Subset the genotype matrix again
s2_genos_mat6 <- s2_genos_mat5[,snp_info4$rs]

## Impute
# Set hets to missing
s2_genos_mat6[s2_genos_mat6 == 0] <- NA

# Impute using mean
s2_genos_imputed <- s2_genos_mat6 %>% 
  apply(MARGIN = 2, FUN = function(snp) {
    # Mean genotype
    mean_geno <- mean(snp, na.rm = T)
    # Round
    mean_geno <- ifelse(mean_geno < 0, -1, 1)
    snp[is.na(snp)] <- mean_geno
    return(snp) })

s2_cap_genos <- s2_genos_imputed + 1

s2_snp_info <- snp_info4

# Convert the genotypes to an array of haploid chromosomes
s2_cap_haploid <- split(s2_cap_genos, 1:nrow(s2_cap_genos), drop = FALSE) %>%
  lapply(FUN = function(ind) rbind(ind / 2, ind / 2) )

# Empty array
s2_cap_haploid_array <- array(data = NA, dim = c(2, ncol(s2_cap_genos), length(s2_cap_haploid)),
                              dimnames = list(NULL, colnames(s2_cap_genos), row.names(s2_cap_genos)))

for (k in seq_along(s2_cap_haploid)) {
  s2_cap_haploid_array[,,k] <- s2_cap_haploid[[k]]
}


# Rename
s2_cap_haploid <- s2_cap_haploid_array


### REMOVE THIS ###
devtools::use_data(s2_cap_genos, s2_snp_info, s2_cap_haploid, overwrite = T)


```

### Six-Row Barley Data

Direct to previous package

```{r}

data("s6_cap_genos")

# Convert the genotypes to an array of haploid chromosomes
s6_cap_haploid <- split(s6_cap_genos, 1:nrow(s6_cap_genos), drop = FALSE) %>%
  lapply(FUN = function(ind) rbind(ind / 2, ind / 2) )

# Empty array
s6_cap_haploid_array <- array(data = NA, dim = c(2, ncol(s6_cap_genos), length(s6_cap_haploid)),
                              dimnames = list(NULL, colnames(s6_cap_genos), row.names(s6_cap_genos)))

for (k in seq_along(s6_cap_haploid)) {
  s6_cap_haploid_array[,,k] <- s6_cap_haploid[[k]]
}


# Rename
s6_cap_haploid <- s6_cap_haploid_array

devtools::use_data(s6_cap_genos, s6_snp_info, s6_cap_haploid, overwrite = T)


```

### Genetic Maps

For both the `s2_snp_info` map and the `s6_snp_info` map, we will take the markers,
find their positions on the @Close2009 map, then create second maps in a list

Unanchored markers in the Close map will be given the same chromosome as in the MA map, however with a position of 0

```{r map.adj}

data("s2_snp_info")
data("s6_snp_info")

# Read in the Close 2009 map
close_map <- read_tsv(file = "C:/Users/Jeff/Google Drive/Barley Lab/Projects/Genomic Selection/Genotypic Data/BOPA Markers/S2TP_BOPA/Unfiltered/geneticMap_Close2009.txt", skip = 1, col_names = c("rs", "chrom", "cM_pos"))

# Calculate cM position from the hecto-Morgan positions given
close_map1 <- close_map %>%
  mutate(cM_pos = cM_pos / 1000)

# Find the positions of the markers in the s2_snp_info and s6_snp_info map in the close_map
s2_snp_info_Close09 <- inner_join(x = close_map1, y = select(s2_snp_info, rs, alleles))

s6_snp_info_Close09 <- inner_join(x = close_map1, y = select(s6_snp_info, rs, alleles))

# Find the chromosome of the unanchored in the MA map
s2_unanchored <- s2_snp_info_Close09 %>%
  filter(chrom == "UNK") %>%
  left_join(y = s2_snp_info, by = c("rs" = "rs", "alleles" = "alleles"))
s6_unanchored <- s6_snp_info_Close09 %>%
  filter(chrom == "UNK") %>%
  left_join(y = s6_snp_info, by = c("rs" = "rs", "alleles" = "alleles"))

# Add those chromosomes in
s2_snp_info_Close09 <- s2_snp_info_Close09 %>% 
  mutate(chrom = ifelse(rs %in% s2_unanchored$rs, s2_unanchored$chrom.y, chrom)) %>%
  select(rs, alleles, chrom, cM_pos) %>%
  arrange(chrom, cM_pos)
  
s6_snp_info_Close09 <- s6_snp_info_Close09 %>% 
  mutate(chrom = ifelse(rs %in% s6_unanchored$rs, s6_unanchored$chrom.y, chrom)) %>%
  select(rs, alleles, chrom, cM_pos) %>%
  arrange(chrom, cM_pos)


# Extract the maps and jitter with R/qtl
s2_map <- s2_snp_info_Close09 %>% 
  split(.$chrom) %>% 
  lapply(function(chr) structure(chr$cM_pos, names = chr$rs, class = "A")) %>% 
  structure(class = "map")

s2_map_jitter <- qtl::jittermap(s2_map)

# Extract the maps and jitter with R/qtl
s6_map <- s6_snp_info_Close09 %>% 
  split(.$chrom) %>% 
  lapply(function(chr) structure(chr$cM_pos, names = chr$rs, class = "A")) %>% 
  structure(class = "map")

s6_map_jitter <- qtl::jittermap(s6_map)


# Add the positions back into map
s2_snp_info_Close09 <- s2_snp_info_Close09 %>% 
  mutate(cM_pos = unlist(s2_map_jitter))

s6_snp_info_Close09 <- s6_snp_info_Close09 %>% 
  mutate(cM_pos = unlist(s6_map_jitter))

devtools::use_data(s2_snp_info_Close09, s6_snp_info_Close09, overwrite = T)


```





## References
