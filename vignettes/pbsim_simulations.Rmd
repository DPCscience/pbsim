---
title: "Simulating Plant Breeding Populations With `pbsim`"
author: "Jeff Neyhart"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---


## Introduction

The `pbsim` package includes a suite of functions for simulating plant breeding programs. The motivation behind this package was to develop a set of tools that would make it simple to simulate plent breeding programs in order to test various methods or procedures. The package is on the simpler side of population genetics simulation tools, however it is nonetheless useful for quick experimentation.

The first step of using the package is to load it using the `library()` function:

```{r load.library}

library(pbsim)

```


## Making a Genome

The first step is to make a geneome object. This is essentially a `list` of class `genome`. The object contains information such as number and length ofchromosomes, marker positions, and genetic architecture.

Simulate a genome with three chromosomes, each with 500 markers.

```{r sim.genome}

n.mar  <- c(500, 500, 500)
len <- c(120, 130, 140)

genome <- sim_genome(len = len, n.mar = n.mar)

```

The output is a `genome` object. A generic `summary` function can be used to summarize the `genome` object.

```{r summarize}

summary(genome)

```

### Define the Genetic Model

The genetic model of a quantitative trait can be specified using the `sim_gen_model()` function. The function is fairly flexible, allowing for custom QTL models including genome location, additive effects, and dominance effects. Alternatively, the location and effects of QTL can be drawn from random distributions.

For instance, you can customize the QTL model by providing a matrix of that information.

```{r cust.qtl}

chromosome <- c(1, 1, 2, 2, 3, 3)
pos <- as.numeric(sapply(X = genome$len, FUN = runif, n = 2, min = 0))
a <- c(1, 0.25, 0.5, 0.25, 0.25, 0.5)
d <- 0

qtl.model <- cbind(chromosome, pos, a, d)

genome <- sim_gen_model(genome, qtl.model)

```

The returned value from `sim_gen_model()` is a `genome` object with information on the genetic model. You can used the same `summary()` function to view a summary of the genetic model

```{r summ.gen.model}

summary(genome)

```



The genetic model can be randomly generated by passing an empty matrix. Here we simulate $L = 15$ QTL. 

We pass the `add.dist = "geometric"` argument to generate additive allelic effects of QTL from a geometric series. As suggested by @Lande1990, the additive effect of QTL $k$ in $k = 1, 2, ..., L$ is $a^k$, where $a = \frac{1 - L}{1 + L}$.

```{r sim.gen.model}

n_qtl <- 15

# Empty matrix
qtl.model <- matrix(nrow = n_qtl, ncol = 4)

genome <- sim_gen_model(genome = genome, qtl.model = qtl.model, add.dist = "geometric")

```

Alternatively, the argument `add.dist = "normal"` can be passed to draw additive effects from a normal distribution.

By default, dominance is assumed absent. However, dominance effects can be specified in the same way that additive effects were specified above. Additionally dominance effects can be generated from a normal distribution by passing the `dom.dist = "normal"` argument

```{r sim.gen.model2}

n_qtl <- 15

# Empty matrix
qtl.model <- matrix(nrow = n_qtl, ncol = 4)

genome <- sim_gen_model(genome = genome, qtl.model = qtl.model, add.dist = "geometric",
                        dom.dist = "normal")

```


The genetic architecture of multiple traits can be simulated by 



## Generate a pedigree

```{r}
ped <- sim_pedigree(n.ind = 30, n.bcgen = 0, n.selfgen = 2)

```

## Simulate a family

```{r}
# First generate founders for a bi-parental population
founder_geno <- sim_founders(genome)

fam <- sim_family(genome, ped, founder_geno)

```

## Simulate a population of many families

```{r}

# First create a crossing block






Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
